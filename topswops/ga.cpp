// ga.cpp

// See http://azspcs.net/Contest/Cards
// Contest ends: Feb. 12 2011, 4pm

/*

This is an attemp at implementing a genetic algorithm (GA) for
topswops. Or, at least, a GA-inspired algorithm as the basic GA
framework usually seems to needs lots of problem-specific tweaking to
make it work well (if at all).

Here is the basic GA algorithm::

  - **Initialization.** Initialize the population, i.e. a set of
    candidate elements. We assume the existence of a fitness function
    f that returns a numeric estimate of the quality of any element in
    the population. Essentially, the GA is optimizing f.

  - **Selection.** A new population is generated by choosing elements
    from the previous generation in a more or less random way that is
    biased by the fitness of the elements, i.e. more fit elements have
    a better chance of surviving into future generates, while less fit
    elements are soon deleted.

  - **Reproduction.** The elements selected in the previous set are
    now "bred", i.e. somehow combined to make a new population. The
    intuiton is that by combining two (or more) pretty good elements
    we may be able to create a new, even better, element.

    **Mutation** is an important part of some GAs, e.g. when combining
    elements small random mistakes may be introduced to increase
    diversity.

    Many, many reproduction operations have been proposed.

Selection and reproduction are repeated until some terminating
condition is met, e.g. a best-possible solution is found, a time-limit
is reached, etc.

 */

#include "topswop.h"

const int POP_SIZE = 100;
const int N = 31;
const double TOP_PCT = 0.75;  // between 0 and 1
const double MUTATE_PCT = 0.20;  // between 0 and 1
const bool LOCAL_IMPROVE = false;
const bool BACK_IMPROVE = true;

const int END_TOP = N * TOP_PCT;
const int BOTTOM_SIZE = N * (1 - TOP_PCT);
const int MUTATE_NUM = N * MUTATE_PCT;

const unsigned int RAND_SEED = 123456;

////////////////////////////////////////////////////////////////////////

vector<Topswop> pop(POP_SIZE);

inline bool less_than(const Topswop& a, const Topswop& b) {
  return a.score() < b.score();
}

inline bool greater_than(const Topswop& a, const Topswop& b) {
  return a.score() > b.score();
}

int total_pop_score() {
  int result = 0;
  for(int i = 0; i < pop.size(); ++i) {
    result += pop[i].score();
  }
  return result;
}

inline void simple_mutate(Topswop& t) {
  for(int i = 0; i < MUTATE_NUM; ++i) {
    t.rand_rev();    
  }
}

// The top 75% (or so) make it to the next generation.
// The other 25% come from mutations of that top 75%.
void select_simple() {
  assert(TOP_PCT >= 0 && TOP_PCT <= 1);

  // sort pop from best to worst
  //noteln("sorting");
  sort(pop.begin(), pop.end(), greater_than);

  // randomly shuffle the top elements of pop
  //noteln("shuffling");
  random_shuffle(pop.begin() + 2, pop.begin() + END_TOP);
  //noteln("copying");
  copy(pop.begin(), pop.begin() + BOTTOM_SIZE, 
       pop.begin() + END_TOP);

  // mutate (1-top_pct) elements of pop
  //noteln("mutating");
  for_each(pop.begin() + END_TOP, pop.end(), simple_mutate);
}

// create a new Topswop of size N with its elements in random order
Topswop init_ga_topswop() {
  Topswop t(N);
  t.randomize();
  return t;
}

// Appear to get better results WITHOUT using local_improve.
void local_improve(Topswop& t) {
  while (t.local_improve_swap_home());
//   while (t.local_improve_swap());
//   while (t.local_improve_reverse());
}

void back_improve(Topswop& t) {
  while (t.back_improve());
}

int ga(long max_iter = 5000000000) {
  //
  // initialization
  //
  //noteln("initialization");
  srand(RAND_SEED);
  generate(pop.begin(), pop.end(), init_ga_topswop);
  int best_tps = total_pop_score();
  vector<Topswop> best_pop(pop);
  Topswop best_overall_topswop = *max_element(pop.begin(), pop.end());
  cout << "Best pop score (0): " << best_tps << endl;
  cout << "Best so far (0): N = " << N << ", score = " 
       << best_overall_topswop.score() << endl
       << "  " << best_overall_topswop << endl;
  
  //noteln("starting main iterations");
  for(long iter = 0; iter < max_iter; ++iter) {
    //noteln(to_string(iter));
    select_simple();
    //noteln("local_improve ...");
    if (LOCAL_IMPROVE) 
      for_each(pop.begin(), pop.end(), local_improve);
    //noteln("back_improve ...");
    if (BACK_IMPROVE) 
      for_each(pop.begin(), pop.end(), back_improve);

    //noteln("calculating tps ...");
    int tps = total_pop_score();
    if (tps > best_tps) {
      best_tps = tps;
      best_pop = pop;
      cout << "Best pop score (" << iter << "): " << best_tps << endl;
    }

    // has a new best individual Topswop been found?
    Topswop best_ts = *max_element(pop.begin(), pop.end());
    if (best_ts > best_overall_topswop) {
      cout << "\nback_dfs ..." << flush;
      for(int times = 0; times < 2; ++times) {
        for(int i = 0; i < pop.size(); ++i) {
          Topswop d = back_dfs(pop[i], 10);
          int diff = d.score() - pop[i].score();
          if (diff > 0) {
            pop[i] = d;
            //cout << "\n! pop[" << i << "] improved by " << diff << endl;
          }
        }
      }
      cout << "done back_dfs" << endl;

      best_ts = *max_element(pop.begin(), pop.end());

      best_overall_topswop = best_ts;
      cout << "Best so far (" << iter << "): N = " << N << ", score = " 
           << best_overall_topswop.score() << endl
           << "  " << best_overall_topswop << endl;
    }
  }
  noteln("all done");
}

int main() {
  cout << "Simple GA Test\n\n";
  print_var("POP_SIZE", POP_SIZE);
  print_var("N", N);
  print_var("TOP_PCT", TOP_PCT);
  print_var("MUTATE_PCT", MUTATE_PCT);
  print_var("END_TOP", END_TOP);
  print_var("MUTATE_NUM", MUTATE_NUM);
  print_var("RAND_SEED", RAND_SEED);
  print_var("LOCAL_IMPROVE", LOCAL_IMPROVE);
  print_var("BACK_IMPROVE", BACK_IMPROVE);
  print_var("BOTTOM_SIZE", BOTTOM_SIZE);
  cout << "\n";
  ga();
}
